
// 1. 입출력

class Solution {
    public int solution(int num1, int num2) {
      
        
     
        int answer = num1 * num2;
       
        
        return answer ;
    }
}

// 1-2. 두수의 곱(비트연산)
// 이진 곱셈(Binary Multiplication)
class Solution {
    static int kake(int a, int b) {
        int res = 0;  
        while (b > 0) {
            if ((b & 1) != 0) res = res + a;
            a = a << 1;
            b = b >> 1;
        }
        return res;
    }

    public int solution(int num1, int num2) {
        return kake(num1, num2);
    }
}
/*

### 주요 개념

1. **비트 연산**:
    - `&`: 두 비트가 모두 1일 때만 1을 반환하는 비트 연산자입니다.
    - `<<`: 비트를 왼쪽으로 시프트(shift)합니다. 이는 숫자를 2배로 만드는 것과 같습니다.
    - `>>`: 비트를 오른쪽으로 시프트(shift)합니다. 이는 숫자를 2로 나누는 것과 같습니다.
2. **알고리즘 설명**:
    - 초기화: `res`는 최종 결과를 저장할 변수로, 처음에 0으로 초기화됩니다.
    - 루프: `b`가 0보다 클 때까지 반복됩니다.
        - `b`의 최하위 비트(1의 자리)를 확인합니다. `b & 1`을 통해 `b`가 홀수이면 `res`에 현재 `a`의 값을 더합니다.
        - `a`를 왼쪽으로 시프트하여 2배로 만듭니다.
        - `b`를 오른쪽으로 시프트하여 2로 나눕니다.
    - 루프가 끝나면 `res`에 최종 곱셈 결과가 저장되고, 이를 반환합니다.

`kake(3, 5)`를 예로 들어보겠습니다.

1. **초기 상태**:
    - `a = 3`, `b = 5` (`b`의 이진 표현: `0101`)
    - `res = 0`
2. **첫 번째 반복**:
    - `b & 1`의 결과는 1 (`b`의 최하위 비트가 1이므로).
    - `res = res + a = 0 + 3 = 3`
    - `a = a << 1 = 3 << 1 = 6`
    - `b = b >> 1 = 5 >> 1 = 2` (`b`의 이진 표현: `0010`)
3. **두 번째 반복**:
    - `b & 1`의 결과는 0 (`b`의 최하위 비트가 0이므로).
    - `res`는 그대로 3
    - `a = a << 1 = 6 << 1 = 12`
    - `b = b >> 1 = 2 >> 1 = 1` (`b`의 이진 표현: `0001`)
4. **세 번째 반복**:
    - `b & 1`의 결과는 1
    - `res = res + a = 3 + 12 = 15`
    - `a = a << 1 = 12 << 1 = 24`
    - `b = b >> 1 = 1 >> 1 = 0` (`b`의 이진 표현: `0000`)
5. **반복 종료**:
    - 이제 `b = 0`이므로 반복이 종료됩니다.
    - `res = 15`이므로 최종 결과는 15가 됩니다.

### 2. 비트 연산의 개념

컴퓨터 내부에서 숫자는 0과 1로 구성된 이진수로 표현됩니다. 비트 연산은 이 이진수를 조작하는 방식으로 연산을 수행합니다. 여기서는 두 가지 중요한 비트 연산에 대해 알아보겠습니다.

- **비트 시프트 연산 (Shift)**: 비트를 왼쪽 또는 오른쪽으로 이동시키는 연산입니다.
    - **왼쪽 시프트 (<<)**: 비트를 왼쪽으로 한 칸 이동시킵니다. 이 경우 숫자는 2배가 됩니다. 예를 들어, `3 << 1`은 3을 왼쪽으로 한 칸 시프트하여 `6`이 됩니다.
    - **오른쪽 시프트 (>>)**: 비트를 오른쪽으로 한 칸 이동시킵니다. 이 경우 숫자는 2로 나뉩니다. 예를 들어, `6 >> 1`은 6을 오른쪽으로 한 칸 시프트하여 `3`이 됩니다.

### 3. 비트 곱셈

비트 곱셈은 위에서 설명한 것처럼, 시프트 연산과 더하기 연산을 조합하여 수행됩니다.

- **핵심 아이디어**: 숫자 `a`를 시프트 연산으로 두 배씩 늘려가면서, `b`의 특정 비트가 1일 때만 그 값을 결과에 더합니다. 이를 통해 곱셈을 수행합니다.

예를 들어, `3 * 5`를 비트 곱셈으로 처리한다면:

- `3`의 이진수는 `0011`, `5`의 이진수는 `0101`입니다.
- `5`의 비트를 왼쪽에서부터 확인하여, 1인 비트의 위치에서 `3`을 2의 배수로 시프트한 값을 더합니다.
- 최종적으로 `15`라는 결과를 얻게 됩니다.

### 4. 비트 나눗셈

비트 나눗셈도 비슷한 개념으로, 시프트 연산을 사용하여 나눗셈을 수행합니다.

- **핵심 아이디어**: 나누어지는 수(피제수)를 반복적으로 오른쪽 시프트하면서 몫을 구합니다.

예를 들어, `15 / 3`을 비트 나눗셈으로 처리한다면:

- `15`의 이진수는 `1111`, `3`의 이진수는 `0011`입니다.
- 3이 15에 몇 번 들어가는지 확인하면서 비트를 오른쪽으로 시프트하여 몫을 구합니다.
- 결과적으로 `5`라는 몫을 얻게 됩니다.








*/
